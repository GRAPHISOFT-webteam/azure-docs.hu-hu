<properties
   pageTitle="Azure 儲存體資料表設計指南 | Microsoft Azure"
   description="在 Azure 資料表儲存體中設計可擴充且高效能的資料表"
   services="storage"
   documentationCenter="na"
   authors="jasonnewyork" 
   manager="tadb"
   editor=""/>

<tags
   ms.service="storage"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="storage"
   ms.date="12/03/2015"
   ms.author="jahogg"/>

# Azure 儲存體資料表設計指南：設計可調整且效用佳的資料表

## 概觀

若要設計可擴充且高效能的資料表，您必須考慮許多因素，例如效能、延展性和成本。 如果您先前曾設計關聯式資料庫的結構描述，您對這些考量會很熟悉，但在部分 Azure 資料表服務儲存體模型和關聯式模型之間相似時，將會有許多重大差異。 這些差異常會導致非常不同的設計，看起來可能違反直覺性，或讓熟悉關聯式資料庫的人覺得不對勁，但如果您設計的是 NoSQL 索引鍵/值存放區 (例如 Azure 資料表服務)，這就顯得合理了。 許多設計差異將會反映表格服務的設計目的是，專門用來支援雲端規模應用程式 (可能包含數十億個資料實體；該實體為關聯式資料庫詞彙中的資料列)，或是支援必須支援極高交易量之資料集的事實：因此，您需要從不同角度思考如何儲存資料，並了解表格服務的運作方式。 相較於使用關聯式資料庫的方案，設計良好的 NoSQL 資料存放區可以讓您更進一步 (並以較低的成本) 進行調整。 本指南可協助您了解這些主題。  

## 關於 Azure 資料表服務

本節強調資料表服務的某些重要功能，特別是關於效能和延展性的設計。 如果您不熟悉 Azure 儲存體和資料表服務，先閱讀 [Microsoft Azure 儲存體簡介](storage-introduction.md) 和 [如何使用資料表儲存體.NET](storage-dotnet-how-to-use-tables.md) 之前先閱讀這篇文章的其餘部分。 雖然本指南的焦點是資料表服務，但仍會討論 Azure 佇列和 Blob 服務，以及如何在方案中將它們與資料表服務搭配使用。  

什麼是資料表服務？ 顧名思義，資料表服務會使用表格格式來儲存資料。 在標準術語中，資料表的每個資料列都代表一個實體，而資料行儲存該實體的各種屬性。 每個實體都有一組金鑰來唯一識別它，且資料表服務會時間戳記資料行追蹤實體上次更新的時間 (這會自動執行，您無法以手動方式用任意值覆寫時間戳記)。 資料表服務會使用這個上次修改的時間戳記 (LMT) 來管理開放式並行存取。  

>[AZURE.NOTE] 資料表服務 REST API 作業也會傳回 **ETag** 它衍生自上次修改時間戳記 (LMT) 的值。 在本文中，我們將交互使用 ETag 和 LMT 詞彙，因為它們參考相同的基礎資料。  

下列範例說明簡單的資料表設計，用以儲存員工和部門的實體。 本指南稍後說明的許多範例皆以這個簡單的設計為基礎。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td>行銷</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>行銷</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>Jun</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>行銷</td>
<td>部門</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>行銷</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>銷售</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


到目前為止，這看起來非常類似於關聯式資料庫中的資料表，主要差異在於必要資料行，並在相同資料表中儲存多個實體類型的能力。 此外，每個使用者定義的屬性，例如 **FirstName** 或 **時代** 具有資料類型，例如整數或字串，就像關聯式資料庫中的資料行。 雖然不同於關聯式資料庫，但資料表服務的無結構描述本質意味著一個屬性在每個實體上不需要相同的資料類型。 若要將複雜資料類型儲存在單一屬性中，您必須使用序列化格式，例如 JSON 或 XML。 如需資料表服務，例如支援資料類型、 支援的日期範圍、 命名規則和大小限制的詳細資訊，請參閱 [了解表格服務資料模型](http://msdn.microsoft.com/library/azure/dd179338.aspx) MSDN 上。

如您所見，您所選擇的 **PartitionKey** 和 **RowKey** 是良好資料表設計的基礎。 儲存在資料表中每個實體必須有唯一的組合 **PartitionKey** 和 **RowKey**。 如同關聯式資料庫資料表中的索引鍵 **PartitionKey** 和 **RowKey** 值編製索引來建立叢集的索引，用於快速查閱; 不過，資料表服務不會建立任何次要索引，會只有兩個索引的屬性 (有些稍後說明的模式會顯示您可以解決這項明顯的限制)。  

資料表由一或多個資料分割所組成，而且如您所見，設計的決策大多會牽涉到選擇適合 **PartitionKey** 和 **RowKey** 來最佳化您的方案。 方案可以僅由單一資料表組成 (其中組織成資料分割的所有實體)，但方案通常會有多個資料表。 資料表可幫助您以邏輯方式組織您的實體，幫助您使用存取控制清單管理資料的存取，而且您可以使用單一儲存體作業放置整個資料表。  

### 資料表的資料分割  
帳戶名稱、 資料表名稱和 **PartitionKey** 共同識別資料表服務儲存實體儲存體服務中的資料分割。 屬於實體定址配置的資料分割可定義交易的範圍 (請參閱 [實體群組交易](#entity-group-transactions) 下方)，並構成的表格服務調整方式。 如需有關資料分割，請參閱 [Azure 儲存體延展性和效能目標](http://msdn.microsoft.com/library/azure/dn249410.aspx)。  

在資料表服務中，個別節點可為一或多個完整資料分割提供服務，且服務會透過動態的負載平衡資料分割在節點間進行調整。 如果節點是在負載下，資料表服務可 *分割* 服務到不同的節點，節點的分割區範圍; 當流量變小時，服務可 *合併* 資料分割範圍從靜止節點重新至單一節點。  

如需詳細資訊之內部詳細資料的資料表服務，並特別如何服務管理資料分割，請參閱本文件 [Microsoft Azure 儲存體: 具有高可用性
雲端儲存體服務具有強式一致性](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)。  

### 實體群組交易
在資料表服務中，實體群組交易 (EGT) 是唯一的內建機制，可跨越多個實體執行不可部分完成的更新。 Egt 也稱為 *批次交易* 某些文件中。 EGT 只能對儲存在相同資料分割中的實體運作 (共用給定資料表中的相同資料分割索引鍵)，所以每當您需要跨多個實體執行不可部分完成的交易行為時，您必須確保這些實體位於相同的資料分割中。 通常就是基於此原因，才需要將多個實體類型放在相同的資料表 (和資料分割) 中，而不讓不同的實體類型使用多個資料表。 單一 EGT 最多可以操作 100 個實體。  如果您送出多個並行 Egt 進行處理很重要，以確保這些 Egt 不會在 Egt 的通用，否則處理可能會延遲的實體上運作。

EGT 也可能讓您必須評估並取捨您的設計：使用多個資料分割會增加應用程式的延展性，因為 Azure 有更多可能在各節點間要求負載平衡，但這可能會限制您的應用程式執行不可部分完成的交易和為資料維護穩固一致性的能力。 此外，有特定的延展性目標的磁碟分割，可能會限制您可以預期的單一節點的交易輸送量層級: 如需 Azure 儲存體帳戶和資料表服務的延展性目標的詳細資訊，請參閱 [Azure 儲存體延展性和效能目標](http://msdn.microsoft.com/library/azure/dd179338.aspx) MSDN 上。 本指南後續幾節將討論各種設計策略，以協助您管理這類的權衡，並討論如何根據您用戶端應用程式的特定需求，選擇您的資料分割索引鍵。  

### 容量考量
下表包含您在設計資料表服務方案時所需注意的某些索引鍵值：  

|Azure 儲存體帳戶的容量總計|500 TB|
|------------------------------------------|------|
|Azure 儲存體帳戶中的資料表數目 | 僅受限於儲存體帳戶的容量 |
|資料表中的資料分割數目 | 僅受限於儲存體帳戶的容量 |
|資料分割中的實體數目 | 僅受限於儲存體帳戶的容量|
|個別實體的大小 | 最多 1 MB，最多 255 個屬性 (包括 **PartitionKey**, ，**RowKey**, ，和 **時間戳記**) |
|大小 **PartitionKey** | 大小最多 1 KB 的字串 |
| 大小 **RowKey** | 大小最多 1 KB 的字串 |
|實體群組交易的大小 | 交易最多可以包含 100 個實體，而承載大小必須小於 4 MB。 一個 EGT 只能更新實體一次。 |

如需詳細資訊，請參閱 [了解表格服務資料模型](http://msdn.microsoft.com/library/azure/dd179338.aspx) MSDN 上。  

### 成本考量  
資料表儲存體比較便宜，但您在評估任何會使用資料表服務的方案時，均應將容量使用量和交易數目的成本預估同時納入考量。 不過，在許多情況下，儲存反正規化或重複的資料以改善方案的效能或延展性，也是可以採行的有效措施。 如需有關定價的詳細資訊，請參閱 [儲存體定價詳細資料](http://azure.microsoft.com/pricing/details/storage/)。  

### 比較 Azure 資料表和 SQL Azure  
Azure SQL Database (關聯式資料庫服務) 和資料表服務之間的比較，請參閱 [Microsoft Azure 資料表儲存體和 Microsoft Azure SQL Database-比較和對照](http://msdn.microsoft.com/library/azure/jj553018.aspx) MSDN 上。  

## 資料表設計指導方針  
這些清單摘要了一些設計資料表時應牢記的重要方針，而本指南稍後將會逐一詳細說明。 這些方針與您往常設計關聯式資料庫時遵循的方針非常不同。  

要將資料表服務方案設計 *讀取* 有效率:

-   ***設計大量讀取應用程式中的查詢。***當您在設計資料表時，請先思考您將執行的查詢 (尤其是較無法容續延遲的查詢)，然後再思考更新實體的方法。 透過這樣的方式，通常可造就一個有效率且高效能的解決方案。  
-   ***在查詢中指定 PartitionKey 和 RowKey。****點查詢* 都是最有效率的資料表服務查詢。  
-   ***考慮儲存重複的實體副本。***資料表儲存體的成本較低，因此請考慮多次儲存相同的實體 (使用不同索引鍵)，以啟用更有效率的查詢。  
-   ***請考慮將資料反正規化。***資料表儲存體十分便宜，所以建議您考慮將資料反正規化。 例如儲存摘要實體，可讓彙總資料的查詢只需存取單一實體。  
-   ***使用複合索引鍵值。***您擁有的唯一索引鍵是 **PartitionKey** 和 **RowKey**。 例如，使用複合索引鍵值啟用替代的實體索引鍵式存取路徑。  
-   ***使用查詢預測。***使用僅選取您所需欄位的查詢，即可減少透過網路傳輸的資料量。  

要將資料表服務方案設計 *撰寫* 有效率:  

-   ***不要建立熱點資料分割。***選擇可讓您在任何時間點，將要求分散到多個分割上的索引鍵。  
-   ***避免產生流量尖峰。***將流量平均分散到合理的時段，以避免產生流量尖峰。
-   ***不一定會建立個別的資料表，每種類型的實體。***需要跨實體類型執行不可部分完成的交易時，您可以在相同資料表的相同分割中儲存多個實體類型。
-   ***請考慮必須達到的最大輸送量。***您必須留意資料表服務的延展性目標，並確保您的設計不會超過目標。  

當您閱讀本指南時，您會看到將這些原則全都納入實作的範例。  

## 查詢的設計  
資料表服務方案可以是讀取密集、寫入密集或兩者混合的方案。 本節主要說明您在設計資料表服務以有效地支援讀取作業時應謹記在心的事項。 一般而言，支援有效讀取作業的設計，也可兼顧寫入作業的效率。 不過，還有其他考量必須牢記在心，設計來支援寫入作業時的下一節中， [資料修改的設計](#design-for-data-modification), ，討論。

要設計資料表服務方案，讓您能夠有效率地讀取資料，您首先可以自問：「我的應用程式需要執行何種查詢以從資料表服務中擷取它所需要的資料？」  

>[AZURE.NOTE] 使用資料表服務時，是正確的設計事先因為它是困難且昂貴，稍後再變更它。 例如，在關聯式資料庫中，通常只要藉由將索引新增至現有的資料庫，就可以解決效能問題：這對於資料表服務是行不通的。  

本節主要討論您在設計查詢資料表時所須解決的重要問題。 本章節涵蓋的主題包括：

- [您選擇的 PartitionKey 和 RowKey 如何影響到查詢效能](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
- [選擇適當的 PartitionKey](#choosing-an-appropriate-partitionkey)
- [使用索引鍵值存放區最佳化資料表服務的查詢](#optimizing-queries-with-a-key-value-store-for-the-table-service)
- [在資料表服務中排序索引鍵值存放區中的資料](#sorting-data-in-a-key-value-store-in-the-table-service)

### 您選擇的 PartitionKey 和 RowKey 如何影響到查詢效能  

下列範例假設表格服務會儲存具有下列結構的員工實體 (大部分的範例省略 **時間戳記** 為了清楚起見屬性):  

|*資料行名稱* |*資料類型*|
|--------------|-----------|
|**PartitionKey** (部門名稱)|String|
|**RowKey** (員工識別碼)|String|
|**FirstName**|String|
|**姓氏**|String|
|**年齡**|Integer|
|**EmailAddress**|String|

先前的章節 [Azure 資料表服務概觀](#azure-table-service-overview) 說明一些有直接影響對查詢設計 Azure 資料表服務的重要功能。 這些功能產生了設計資料表服務查詢的一般指導方針。 請注意，在下列範例中使用的篩選語法來自資料表服務 REST API; 如需詳細資訊，請參閱 [查詢實體](http://msdn.microsoft.com/library/azure/dd179421.aspx) MSDN 上。  

-   A ***點查詢*** 是使用最有效率的查閱，建議用於高容量查閱或需要最低延遲的查閱。 這類查詢可以使用索引來指定這兩者非常有效率的方式尋找個別實體 **PartitionKey** 和 **RowKey** 值。 例如：
$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')  
-   次佳的是 ***範圍查詢*** 使用 **PartitionKey** 和範圍的篩選 **RowKey** 值來傳回多個實體。  **PartitionKey** 值會識別特定的資料分割，而 **RowKey** 值會識別該資料分割中實體的子集。 例如：
$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'  
-   其次是 ***分割掃描*** 使用 **PartitionKey** ，另一個非索引鍵屬性，而且該篩選器可能會傳回一個以上的實體。  **PartitionKey** 值會識別特定的資料分割，而屬性值會選取該分割中實體的子集。 例如：
$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'  
-   A ***資料表掃描*** 不包括 **PartitionKey** 和就非常沒有效率，因為它會搜尋所有組成資料表會針對任何相符的實體磁碟分割。 它會執行資料表掃描，無論您的篩選是否使用 **RowKey**。 例如：
$filter=LastName eq 'Jones'  
-   傳回多個實體的查詢會傳回它們在排序 **PartitionKey** 和 **RowKey** 順序。 若要避免重新在用戶端實體，請選擇 **RowKey** 定義最常見的排序次序。  

請注意，使用 「**或**」 指定為基礎的篩選條件 **RowKey** 值產生資料分割掃描並不會被視為範圍查詢。 因此，您應避免使用如下篩選的查詢：
$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')  

如需使用儲存體用戶端程式庫執行有效率查詢的用戶端程式碼範例，請參閱：  

-   [使用儲存體用戶端程式庫擷取單一實體](#retrieving-a-single-entity-using-the-storage-client-library)
-   [使用 LINQ 擷取多個實體](#retrieving-multiple-entities-using-linq)
-   [伺服器端預測](#server-side-projection)  

如需可對儲存在相同資料表中的多個實體類型進行處理的用戶端程式碼範例，請參閱：  

-   [使用異質性實體類型](#working-with-heterogeneous-entity-types)  

### 選擇適當的 PartitionKey  

您所選擇的 **PartitionKey** 應兼顧 Egt (以確保一致性) 的使用和您的實體分散到多個資料分割 (以確保可調整的解決方案) 的需求。  

就一個極端而言，您可以在單一磁碟分割儲存您的實體，但這可能會限制方案的延展性，且會妨礙資料表服務的負載平衡要求。 就另一個極端而言，您可以為每個資料分割儲存一個實體以達到高擴充性，並且讓資料表服務可進行負載平衡要求，但這會讓您無法使用實體群組交易。  

理想 **PartitionKey** 時，可讓您使用有效率的查詢，而且具有足夠的磁碟分割，以確保您的解決方案進行調整。 一般而言，您會發現您的實體將具有適當的屬性，可將您的實體分散到足夠的磁碟分割。

>[AZURE.NOTE] 例如，在系統中儲存使用者或員工相關資訊，使用者識別碼可能是一個良好的 PartitionKey。 您可能需要數個使用指定的 UserID 做為資料分割索引鍵的實體。 儲存使用者相關資料的每個實體會分組到單一資料分割，因此這些實體可透過實體群組交易來存取，同時仍具有高擴充性。

在您選擇的其他考量 **PartitionKey** 相關方式會在其中插入、 更新和刪除實體的: 請參閱章節 [資料修改的設計](#design-for-data-modification) 下方。  

### 最佳化資料表服務的查詢  

資料表服務自動編製索引的實體使用 **PartitionKey** 和 **RowKey** 的單一叢集索引中的值，因此，點查詢是最有效率的使用。 不過，在沒有其他索引的叢集索引上 **PartitionKey** 和 **RowKey**。

許多設計必須符合需求，才能讓您根據多個準則查閱實體。 比方說，根據電子郵件、員工識別碼或姓氏找出員工實體。 一節中的下列模式 [資料表設計模式](#table-design-patterns) 這些類型的需求，並說明解決的事實資料表服務不提供次要索引的方式:  

-   [內部資料分割次要索引模式](#intra-partition-secondary-index-pattern) -儲存多個複本的每個實體使用不同 **RowKey** 值 (在相同的資料分割) 啟用快速和有效率查閱和替代排序次序使用不同 **RowKey** 值。  
-   [間分割次要索引模式](#inter-partition-secondary-index-pattern) -儲存多個複本的每個實體使用不同 RowKey 值在個別資料分割或個別資料表中啟用快速和有效率查閱和替代排序次序使用的不同 **RowKey** 值。  
-   [索引實體模式](#index-entities-pattern) -維護索引項目，啟用有效的搜尋以傳回實體清單。  

### 在資料表服務中排序資料  

資料表服務會傳回以遞增方式排序依據的實體 **PartitionKey** 、 再根據 **RowKey**。 這些索引鍵是字串值，若要確保能正確排序數字值，您應該將它們轉換成固定長度，並以零填補它們。 例如，如果您使用做為員工識別碼值 **RowKey** 是整數值，您應將員工識別碼轉換成 **123** 至 **00000123**。  

許多應用程式都需要使用以不同順序排序的資料：例如，依名稱或加入日期為員工排序。 一節中的下列模式 [資料表設計模式](#table-design-patterns) 強調如何為您的實體取代排序次序:  

-   [內部資料分割次要索引模式](#intra-partition-secondary-index-pattern) -儲存多個複本的每個實體使用不同 RowKey 值 (在相同的資料分割) 啟用快速和有效率查閱和替代排序次序使用的不同 RowKey 值。  
-   [間分割次要索引模式](#inter-partition-secondary-index-pattern) -儲存多個複本的每個實體使用不同 RowKey 值在個別資料表中的個別資料分割，以便快速和有效率查閱和替代排序次序使用的不同 RowKey 值。
-   [記錄檔結尾模式](#log-tail-pattern) -擷取 *n* 最近新增至資料分割所使用的實體 **RowKey** 以反向的日期和時間順序排序的值。  

## 資料修改的設計
本節著重於最佳化插入、更新和刪除的設計考量。 在某些情況下，您必須在查詢最佳化的設計與資料修改最佳化的設計之間評估取捨，如同您在設計關聯式資料庫時一般 (雖然在關聯式資料庫中用來管理設計取捨的方法有所不同)。 區段 [資料表設計模式](#table-design-patterns) 說明表格服務的一些詳細的設計模式，並強調一些取捨。 在實務上，您會發現許多針對查詢實體而最佳化的設計也適用於修改實體。  

### 最佳化插入、更新和刪除作業的效能  

若要更新或刪除實體，您必須使用識別 **PartitionKey** 和 **RowKey** 值。 在這方面，您所選擇的 **PartitionKey** 和 **RowKey** 的修改實體應該遵循類似準則，以便支援點查詢，因為您想要盡可能有效率地識別實體。 您不想使用效率不佳的資料分割或資料表掃描來尋找實體以探索 **PartitionKey** 和 **RowKey** 需要更新或刪除的值。  

一節中的下列模式 [資料表設計模式](#table-design-patterns) 說明最佳化效能或插入、 更新和刪除作業:  

-   [大量刪除模式](#high-volume-delete-pattern) -讓您能夠刪除大量的實體將同時刪除所有的項目儲存在其自己的個別資料表，您可以藉由刪除資料表刪除實體。  
-   [資料序列模式](#data-series-pattern) -將完整資料序列儲存在單一實體中，盡可能減少您提出的要求數。  
-   [寬型實體模式](#wide-entities-pattern) -使用多個實體的實體來儲存具有超過 252 個屬性的邏輯實體。  
-   [大型實體模式](#large-entities-pattern) -使用 blob 儲存體來儲存大型屬性值。  

### 確保預存實體中的一致性  

另一個會在您選擇最佳化資料修改的索引鍵時造成影響的主要因素，是如何使用不可部分完成的交易確保一致性。 只有對於儲存在相同資料分割中的實體，才能使用 EGT 來運作。  

一節中的下列模式 [資料表設計模式](#table-design-patterns) 說明管理一致性:  

-   [內部資料分割次要索引模式](#intra-partition-secondary-index-pattern) -儲存多個複本的每個實體使用不同 **RowKey** 值 (在相同的資料分割) 啟用快速和有效率查閱和替代排序次序使用不同 **RowKey** 值。  
-   [間分割次要索引模式](#inter-partition-secondary-index-pattern) -儲存多個複本的每個實體使用不同 RowKey 值在個別資料分割或個別資料表中啟用快速和有效率查閱和替代排序次序使用的不同 **RowKey** 值。  
-   [最終一致的交易模式](#eventually-consistent-transactions-pattern) -使用 Azure 佇列，跨資料分割界限或儲存體系統界限啟用最終一致的行為。
-   [索引實體模式](#index-entities-pattern) -維護索引項目，啟用有效的搜尋以傳回實體清單。  
-   [去正規化模式](#denormalization-pattern) -將相關資料結合在單一實體中，您可以擷取您需要使用單點查詢的所有資料。  
-   [資料序列模式](#data-series-pattern) -將完整資料序列儲存在單一實體中，盡可能減少您提出的要求數。  

實體群組交易的相關資訊，請參閱區段 [實體群組交易](#entity-group-transactions)。  

### 確保您針對有效率的修改所做的設計有助於提升查詢效率  

在許多情況下，效率查詢的設計都可造就有效的修改，但是您務必要評估這對您的特定案例是否適用。 某些模式 > 一節 [資料表設計模式](#table-design-patterns) 明確評估取捨查詢和修改實體，而且您應該一律考量每一種作業的數目。  

一節中的下列模式 [資料表設計模式](#table-design-patterns) 取捨設計有效資料修改與設計之間進行有效率的查詢:  

-   [複合索引鍵模式](#compound-key-pattern) -使用複合 **RowKey** 值，讓用戶端查閱與單點查詢的相關的資料。  
-   [記錄檔結尾模式](#log-tail-pattern) -擷取 *n* 最近新增至資料分割所使用的實體 **RowKey** 以反向的日期和時間順序排序的值。  

## 加密資料表的資料    
     
.NET Azure 儲存體用戶端程式庫支援在插入和取代作業時進行字串實體屬性的加密。 加密的字串儲存在服務上作為二進位屬性，且解密後會轉換回字串。    

針對資料表，除了加密原則之外，使用者必須指定要加密的屬性。 作法是指定 [EncryptProperty] 屬性 (針對衍生自 TableEntity 的 POCO 實體)，或在要求選項中指定加密解析程式。 加密解析程式是委派，接受資料分割索引鍵、資料列索引鍵和屬性名稱，然後傳回布林值，指出是否應該加密該屬性。 在加密期間，用戶端程式庫會使用此資訊，決定將屬性在寫到網路時是否應該加密。 委派也提供關於屬性如何加密的可能邏輯。 (例如，如果 X，則加密屬性 A，否則加密屬性 A 和 B。)請注意，讀取或查詢實體時不需要提供這項資訊。

請注意目前不支援合併。 因為屬性子集先前可能是使用不同的金鑰加密，直接合併新的屬性並更新中繼資料會導致資料遺失。 合併可能需要額外的服務呼叫來從服務讀取預先存在的實體，或在每個屬性上都使用新的金鑰，兩者都不利用於效能。     

加密資料表資料的相關資訊，請參閱 [用戶端加密和 Microsoft Azure 儲存體的 Azure 金鑰保存庫](storage-client-side-encryption.md)。  

## 模型化關聯性  

建置網域模型是設計複雜系統時的關鍵步驟。 一般而言，您可以使用模型化程序來識別實體及其之間的關聯性，藉此了解商業網域，並告知您的系統設計。 本節主要說明如何轉譯網域模型中一些常見的關聯性類型，以設計資料表服務。 從邏輯資料模型對應至實體 NoSQL 架構資料模型的程序，與設計關聯式資料庫時使用的程序非常不同。 關聯式資料庫設計通常會採用針對最小化備援性而最佳化的資料正規化程序，再搭配宣告式查詢功能以說明如何實作資料庫的運作方式。  

### 一對多關聯性  

商業網域物件之間常會產生一對多關聯性：例如，一個部門有許多員工。 有數種方式可用來實作資料表服務中的一對多關聯性，每種方式都有其可能與特定狀況相關的優缺點。  

舉例來說，假設某家大型跨國公司有數十萬個部門和員工實體，其中每個部門都有許多員工，且每位員工都與一個特定部門相關聯。 其中一個方法是儲存個別部門和這些員工實體，如下所示：  

![][1]

此範例顯示根據型別之間的隱含一對多的關聯性 **PartitionKey** 值。 每個部門可以有許多員工。  

此範例也說明相同資料分割中的部門實體及其相關聯的員工實體。 您可以選擇為不同的實體類型使用不同的資料分割、資料表甚或儲存體帳戶。  

替代方式是將資料去正規化，並只使用去正規化的部門資料儲存員工實體，如下列範例所示。 在此特定案例中，如果您需要能夠變更部門經理的詳細資料，這個去正規化方法可能不是最佳選擇，因為此時您必須更新部門中的每一位員工。  

![][2]

如需詳細資訊，請參閱 [去正規化模式](#denormalization-pattern) 本指南稍後的。  

下表摘要說明前述用來儲存具有一對多關聯性的員工和部門實體的各種方法有何優缺點。 您也應考慮您要執行各種作業的頻率：如果不常執行作業，則使包含高成本作業的設計，或許是可行的。  

<table>
<tr>
<th>方法</th>
<th>優點</th>
<th>缺點</th>
</tr>
<tr>
<td>個別的實體類型、相同的資料分割、相同的資料表</td>
<td>
<ul>
<li>您可以使用單一作業更新部門實體。</li>
<li>如果您需要在每次更新/插入/刪除員工實體時修改部門實體，您可以使用 EGT 來維持一致性。 例如，假設您維護每個部門的部門員工計數。</li>
</ul>
</td>
<td>
<ul>
<li>您可能需要針對某些用戶端活動同時擷取員工和部門實體。</li>
<li>儲存作業會在相同資料分割中執行。 在交易量偏高時，這可能會導致熱點。</li>
<li>您無法使用 EGT 將員工移至新部門。</li>
</ul>
</td>
</tr>
<tr>
<td>個別的實體類型、不同的資料分割或資料表或儲存體帳戶</td>
<td>
<ul>
<li>您可以使用單一作業更新部門實體或員工實體。</li>
<li>在交易量偏高時，這可能有助於將負載分散到多個資料分割。</li>
</ul>
</td>
<td>
<ul>
<li>您可能需要針對某些用戶端活動同時擷取員工和部門實體。</li>
<li>當您更新/插入/刪除員工和更新部門時，您無法使用 EGT 維護一致性。 例如，更新某個部門實體中的員工計數。</li>
<li>您無法使用 EGT 將員工移至新部門。</li>
</ul>
</td>
</tr>
<tr>
<td>去正規化為單一實體類型</td>
<td>
<ul>
<li>您可以透過單一要求擷取您所需的所有資訊。</li>
</ul>
</td>
<td>
<ul>
<li>如果您需要更新部門資訊，維持一致性可能會很昂貴 (您可能必須更新部門中的所有員工)。</li>
</ul>
</td>
</tr>
</table>

您選擇這些選項的方式及其優缺點是最重要的，這取決於您的應用程式案例。 例如，您多久修改一次部門實體；您所有的員工查詢是否都需要其他部門資訊；您的磁碟分割或儲存體帳戶有多接近延展性限制？  

### 一對一關聯性  

網域模型的實體之間可能會包含一對一關聯性。 如果您需要在資料表服務中實作一對一關聯性，您在需要同時擷取兩個相關的實體時，也必須選擇如何連結兩者。 此連結可以是隱含、 根據慣例，以在索引鍵的值，或明確的形式儲存連結 **PartitionKey** 和 **RowKey** 值在每個實體中，其相關的實體。 如需是否應將相關的實體儲存在相同的資料分割中的討論，請參閱 [一對多關聯性](#one-to-many-relationships)。  

請注意，有也可能會導致您在資料表服務中實作一對一關聯性的實作考量：  

-   處理大型實體 (如需詳細資訊，請參閱 [使用大型實體](#working-with-large-entities))。  
-   實作存取控制 (如需詳細資訊，請參閱 [透過共用存取簽章控制存取](#controlling-access-with-shared-access-signatures))。  

### 用戶端中的聯結  

雖然有多種方式可以模型化資料表服務中的關聯性，但您應該記住，使用資料表服務的兩個主要原因是延展性和效能。 如果您發現您將許多包含方案的效能和延展性的關聯性模型化，您應該自問是否需要在資料表設計中建置所有的資料關聯性。 如果您讓用戶端應用程式執行任何必要的聯結，或許可以簡化設計並改善方案的效能與延展性。  

例如，如果您有小型資料表，且其中包含未經常變更的資料，您就可以擷取此資料一次，並在用戶端上加以快取。 這可以避免重複擷取相同資料的往返。 在我們已於本指南中討論的範例中，小型組織中的部門集合很可能較小且不常變更，因此適合做為可由用戶端應用程式下載一次並快取為查閱資料的資料。  

### 繼承關聯性  

如果您的用戶端應用程式使用一組形成部分繼承關聯性的類別來代表商業實體，您可以輕鬆地在資料表服務中保存這些實體。 比方說，您可能必須將下列用戶端應用程式中定義的類別， **人** 是抽象類別。

![][3]

您可以透過使用實體如下所示的單一 Person 資料表，在資料表服務中保存兩個固定類別的執行個體：  

![][4]

如需有關使用多個用戶端程式碼中的相同資料表中的實體類型，請參閱一節 [使用異質性實體類型](#working-with-heterogeneous-entity-types) 本指南稍後的。 其中提供如何在用戶端程式碼中辨識實體類型的範例。  

## 資料表設計模式
在前幾節中，您已看到一些關於如何針對使用查詢擷取實體資料和插入、更新及刪除實體資料最佳化您的資料表設計的詳細討論。 本節將說明一些適用於資料表服務方案的模式。 此外，您會看到您如何有效處理先前在本指南中提及的一些問題和取捨。 下圖摘要說明不同模式之間的關聯性：  

![][5]

上方的模式圖強調顯示本指南中提及的模式 (藍色) 與反向模式 (橘色) 之間的一些關聯性。 當然還有許多其他模式也值得考量。 例如，資料表服務的主要案例的其中一個是儲存 [具體化檢視](https://msdn.microsoft.com/library/azure/dn589782.aspx) 從 [命令查詢責任隔離](https://msdn.microsoft.com/library/azure/jj554200.aspx) (CQRS) 模式。  

### 內部資料分割次要索引模式
儲存多個複本的每個實體使用不同 **RowKey** 值 (在相同的資料分割) 啟用快速和有效率查閱和替代排序次序使用不同 **RowKey** 值。 複本之間的更新可以使用 EGT 保持一致。  

#### 內容和問題
資料表服務自動編製索引的實體使用 **PartitionKey** 和 **RowKey** 值。 這可讓用戶端應用程式使用這些值有效率地擷取實體。 例如，使用如下所示的資料表結構，用戶端應用程式可以使用點查詢透過部門名稱和員工識別碼擷取個別員工實體 ( **PartitionKey** 和 **RowKey** 值)。 用戶端也可以擷取每個部門內以員工識別碼排序的實體。

![][6]

如果您也想能夠根據其他屬性 (例如電子郵件地址) 的值尋找員工實體，您必須使用效率較低的資料分割掃描來尋找相符項目。 這是因為資料表服務不會提供次要索引。 此外，沒有要求以外的不同順序來排序的員工清單選項 **RowKey** 順序。  

#### 方案
若要解決缺少次要索引，您可以儲存每個實體，且每個複本分別使用不同的多個複本 **RowKey** 值。 如果您使用如下所示的結構來儲存實體，就能夠根據電子郵件地址或員工識別碼，有效率地擷取員工實體。 前置詞值 **RowKey**, ，"empid_"和"email_"可讓您使用電子郵件地址或員工識別碼範圍查詢單一員工或某個範圍的員工。  

![][7]

下列兩個篩選準則 (一個依員工識別碼查閱，另一個依電子郵件地址查閱) 都會指定點查詢：  

-   $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
-   $filter = (PartitionKey eq 'Sales') 和 (RowKey eq 'email_jonesj@contoso.com')  

如果您查詢某範圍的員工實體，您可以指定以員工識別碼順序，排序的範圍或範圍，以電子郵件地址順序排序查詢的實體中的適當前置詞 **RowKey**。  

-   若要在銷售部門中尋找員工識別碼介於 000100 到 000199 之間的所有員工，請使用：
$filter = (PartitionKey eq 'Sales') 和 (RowKey ge 'empid_000100') 和 (RowKey le 'empid_000199')  
-   若要尋找銷售部門中的所有員工，開頭為字母 'a' 使用電子郵件地址:
$filter = (PartitionKey eq 'Sales') 和 (RowKey ge 'email_a') 和 (RowKey lt 'email_b')  

 請注意，上述範例中使用的篩選語法來自資料表服務 REST API; 如需詳細資訊，請參閱 [查詢實體](http://msdn.microsoft.com/library/azure/dd179421.aspx) MSDN 上。  

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  

-   資料表儲存體的使用成本相對較低廉，因此儲存重複資料的成本負擔應該不是主要的考量。 不過，您一律應根據預期的儲存需求評估設計成本，並僅新增重複實體來支援用戶端應用程式將會執行的查詢。  
-   因為次要索引實體儲存在與原始實體相同的磁碟分割中，因此您應該確定不會超過個別資料分割的延展性目標。  
-   您可以將重複實體彼此保持一致，方法是使用 EGT 自動更新實體的兩個複本。 這表示您應該將實體的所有複本儲存在相同的資料分割中。 如需詳細資訊，請參閱 [使用實體群組交易](#entity-group-transactions)。  
-   這個值用來 **RowKey** 必須是唯一的每個實體。 請考慮使用複合索引鍵值。  
-   填補數值在 **RowKey** (例如，員工識別碼 000223)，可正確進行排序和篩選根據的上限與下限。  
-   您不一定需要複製實體的所有屬性。 例如，如果查詢實體使用電子郵件地址中查閱 **RowKey** 永遠都不需要員工的年齡，這些實體可以有下列結構:

![][8]

-   一般而言，儲存重複資料並確保您可以透過單一查詢擷取您需要的所有資料，通常會比使用一個查詢來尋找實體並以另一個查閱所需資料更為理想。  

#### 使用此模式的時機  

當用戶端應用程式需要使用各種不同的索引鍵擷取實體時、當用戶端需要擷取不同排序次序的實體時，以及您可以使用不同的唯一值識別每個實體時，請使用此模式。 不過，您應該確定您在執行使用不同的實體查閱時，您不超出資料分割延展性限制 **RowKey** 值。  

#### 相關的模式和指引  

在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [間分割次要索引模式](#inter-partition-secondary-index-pattern)
-   [複合索引鍵模式](#compound-key-pattern)
-   [實體群組交易](#entity-group-transactions)
-   [使用異質性實體類型](#working-with-heterogeneous-entity-types)

### 間分割次要索引模式
儲存多個複本的每個實體使用不同 **RowKey** 值在個別資料分割或個別資料表中能快速且有效率地查閱和替代排序次序使用不同 **RowKey** 值。  

#### 內容和問題
資料表服務自動編製索引的實體使用 **PartitionKey** 和 **RowKey** 值。 這可讓用戶端應用程式使用這些值有效率地擷取實體。 例如，使用如下所示的資料表結構，用戶端應用程式可以使用點查詢透過部門名稱和員工識別碼擷取個別員工實體 ( **PartitionKey** 和 **RowKey** 值)。 用戶端也可以擷取每個部門內以員工識別碼排序的實體。  

![][9]

如果您也想能夠根據其他屬性 (例如電子郵件地址) 的值尋找員工實體，您必須使用效率較低的資料分割掃描來尋找相符項目。 這是因為資料表服務不會提供次要索引。 此外，沒有要求以外的不同順序來排序的員工清單選項 **RowKey** 順序。  

您預期這些實體會有極大量的交易，而想要為您的用戶端節流以將資料表服務的風險降至最低。  

#### 方案  
若要解決缺少次要索引，您可以儲存多個複本的每個實體的每個複製使用不同 **PartitionKey** 和 **RowKey** 值。 如果您使用如下所示的結構來儲存實體，就能夠根據電子郵件地址或員工識別碼，有效率地擷取員工實體。 前置詞值 **PartitionKey**, ，"empid_"和"email_"可讓您找出您想要用於查詢的索引。  

![][10]

下列兩個篩選準則 (一個依員工識別碼查閱，另一個依電子郵件地址查閱) 都會指定點查詢：  

-   $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
-   $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

如果您查詢某範圍的員工實體，您可以指定以員工識別碼順序，排序的範圍或範圍，以電子郵件地址順序排序查詢的實體中的適當前置詞 **RowKey**。  

-   若要尋找在銷售部門員工識別碼範圍中的所有員工 **000100** 至 **000199** 用於員工識別碼順序排序:
$filter = (PartitionKey eq ' empid_Sales') 和 (RowKey ge '000100') 和 (RowKey le '000199')  
-   若要尋找開頭為 'a' 中的電子郵件的電子郵件地址的銷售部門中的所有員工地址順序使用:
$filter = (PartitionKey eq ' email_Sales') 和 (RowKey ge 'a') 和 (RowKey lt 'b')  

請注意，上述範例中使用的篩選語法來自資料表服務 REST API; 如需詳細資訊，請參閱 [查詢實體](http://msdn.microsoft.com/library/azure/dd179421.aspx) MSDN 上。  

#### 問題和考量  
當您決定如何實作此模式時，請考慮下列幾點：  

-   您可以讓重複實體彼此之間始終保持一致使用 [最終一致的交易模式](#eventually-consistent-transactions-pattern) 來維護主要和次要索引實體。  
-   資料表儲存體的使用成本相對較低廉，因此儲存重複資料的成本負擔應該不是主要的考量。 不過，您一律應根據預期的儲存需求評估設計成本，並僅新增重複實體來支援用戶端應用程式將會執行的查詢。  
-   這個值用來 **RowKey** 必須是唯一的每個實體。 請考慮使用複合索引鍵值。  
-   填補數值在 **RowKey** (例如，員工識別碼 000223)，可正確進行排序和篩選根據的上限與下限。  
-   您不一定需要複製實體的所有屬性。 例如，如果查詢實體使用電子郵件地址中查閱 **RowKey** 永遠都不需要員工的年齡，這些實體可以有下列結構:

    ![][11]

-   一般而言，儲存重複資料並確保您可以透過單一查詢擷取您需要的所有資料，通常會比使用一個查詢透過次要索引尋找實體、並以另一個查詢來查閱主要索引中的所需資料更為理想。  

#### 使用此模式的時機  
當用戶端應用程式需要使用各種不同的索引鍵擷取實體時、當用戶端需要擷取不同排序次序的實體時，以及您可以使用不同的唯一值識別每個實體時，請使用此模式。 如果您想要避免超出資料分割延展性限制，當您執行使用不同的實體查閱時使用此模式 **RowKey** 值。  

#### 相關的模式和指引
在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [最終一致的交易模式](#eventually-consistent-transactions-pattern)  
-   [內部資料分割次要索引模式](#intra-partition-secondary-index-pattern)  
-   [複合索引鍵模式](#compound-key-pattern)  
-   [實體群組交易](#entity-group-transactions)  
-   [使用異質性實體類型](#working-with-heterogeneous-entity-types)  

### 最終一致的交易模式  

使用 Azure 佇列，跨資料分割界限或儲存體系統界限啟用最終一致的行為。  

#### 內容和問題  

EGT 可讓您在共用相的資料分割索引鍵的多個實體之間執行不可部分完成的交易。 基於效能和擴充性的考量，您可能會決定在個別的磁碟分割或不同的儲存體系統中儲存有一致性需求的實體：在這種情況下，您無法使用 EGT 維護一致性。 例如，您可能必須在下列項目間維護最終一致性：  

-   儲存在相同資料表的兩個不同資料分割中、不同的資料表中、不同儲存體帳戶中的實體。  
-   儲存在資料表服務中的實體和儲存在 Blob 服務中的 Blob。  
-   儲存在資料表服務中的實體和檔案系統中的檔案。  
-   儲存在資料表服務中、但使用 Azure 搜尋服務編製索引的實體。  

#### 方案  

藉由使用 Azure 佇列，您可以實作解決方案，提供跨兩個或多個資料分割或儲存系統的最終一致性。
為了說明這種方法，我們假設您需要能夠封存舊的員工實體。 舊的員工實體很少受到查詢，應從處理目前員工的任何活動中排除。 若要實作這項需求中，您儲存作用中的員工 **目前** 資料表並將舊員工在 **封存** 資料表。 封存員工需要先刪除實體 **目前** 資料表，並將實體加入 **封存** 資料表，但您無法使用 EGT 來執行這兩項作業。 若要避免因失敗而導致實體同時出現或未出現在這兩個資料表中，封存作業必須最終一致。 下列順序圖說明此作業的步驟。 後續文字提供了例外狀況路徑的詳細資料。  

![][12]

用戶端會藉由將訊息放在 Azure 佇列來起始封存作業，在此範例中會封存員工 #456。 背景工作角色會輪詢佇列中的新訊息；若找到新訊息，它會讀取訊息，並將隱藏的複本保留在佇列上。 背景工作角色接著會擷取一份實體 **目前** 資料表中插入複本 **封存** 資料表，然後再刪除原始從 **目前** 資料表。 最後，如果前述步驟沒有任何錯誤，背景工作角色會從佇列中刪除隱藏的訊息。  

在此範例中，步驟 4 會將員工插入 **封存** 資料表。 這可以將員工新增至 Blob 服務中的 Blob 或檔案系統中的檔案。  

#### 從失敗復原  

很重要的步驟中的作業 **4** 和 **5** 必須 *等冪* 萬一背景工作角色必須重新啟動封存作業。 如果您使用資料表服務，如步驟 **4** 您應使用 「 插入或取代 」 作業; 在步驟 **5** 應該使用 「 如果刪除存在 」 會使用用戶端程式庫中的作業。 如果您使用其他儲存體系統，您必須使用適當的冪等作業。  

如果背景工作角色一直未完成步驟 **6**, ，則逾時之後再次出現訊息佇列可讓背景工作角色，以嘗試重新加以處理。 背景工作角色可以檢查訊息在佇列上的已讀取次數，如有必要可將其傳送至不同的佇列，以標示為「有害」訊息接受調查。 如需讀取佇列訊息及檢查清除佇列計數的詳細資訊，請參閱 [取得訊息](https://msdn.microsoft.com/library/azure/dd179474.aspx)。  

來自資料表和佇列服務的某些錯誤是暫時性的，用戶端應用程式應包含適當的重試邏輯來處理它們。  

#### 問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

-   此方案不提供交易隔離。 例如，用戶端無法讀取 **目前** 和 **封存** 資料表時的背景工作角色是兩個步驟 **4** 和 **5**, ，並且會看見不一致的資料檢視。 請注意，資料最終將會一致。  
-   您必須確定步驟 4 和 5 是等冪，以確保最終一致性。  
-   您可以使用多個佇列和背景工作角色執行個體來調整方案。  

#### 使用此模式的時機  
如果您想要確保存在於不同磁碟分割或資料表中的實體之間保有最終一致性，請使用此模式。 您可以擴充此模式，以確保整個表格服務與 Blob 服務和其他非 Azure 儲存體資料來源 (例如資料庫或檔案系統) 的作業保有最終一致性。  

#### 相關的模式和指引  
在實作此模式時，下列模式和指導方針也可能有所關聯：  
-   [實體群組交易](#entity-group-transactions)  
-   [合併或取代](#merge-or-replace)  

>[AZURE.NOTE] 如果您的方案的重要交易隔離，您應該考慮重新設計，可讓您能夠使用 Egt 資料表。  

### 索引實體模式
維護索引項目，啟用有效的搜尋以傳回實體清單。  

#### 內容和問題  

資料表服務自動編製索引的實體使用 **PartitionKey** 和 **RowKey** 值。 這可讓用戶端應用程式使用點查詢有效率地擷取實體。 例如，使用如下所示的資料表結構，用戶端應用程式可以有效率地擷取個別員工實體使用部門名稱和員工識別碼 ( **PartitionKey** 和 **RowKey**)。  

![][13]

如果您也想能夠根據其他非唯一屬性 (例如其姓氏) 的值擷取員工實體清單，您必須使用效率較低的資料分割掃描來尋找相符項目，而不要使用索引直接加以查閱。 這是因為資料表服務不會提供次要索引。  

#### 方案  

若要透過如上所示的實體結構啟用依據姓氏的查閱，您必須維護員工識別碼清單。 如果您想要擷取具有特定姓氏 (例如 Jones) 的員工實體，您必須先針對姓氏為 Jones 的員工找出員工識別碼清單，然後擷取這些員工實體。 有三個主要的選項可儲存員工識別碼清單：  

-   使用 Blob 儲存體。  
-   在與員工實體相同的磁碟分割中建立索引實體。  
-   在個別的資料分割或資料表中建立索引實體。  

<u>選項 #1: 使用 blob 儲存體</u>  

第一個選項時，您建立的每個唯一的姓氏，以及每個 blob 存放區中的 blob 清單的 **PartitionKey** (部門) 和 **RowKey** 具有該姓氏的員工 (員工識別碼) 值。 當您新增或刪除某位員工時，您應該確保相關的 Blob 內容與員工實體最終一致。  

<u>選項 2:</u> 在相同的資料分割中建立索引實體  

使用第二個選項時，您會使用儲存下列資料的索引實體：  

![][14]

 **EmployeeIDs** 屬性包含員工識別碼清單的員工姓氏儲存在 **RowKey**。  

下列步驟概述您在使用第二個選項並且要新增員工時所應遵循的程序。 在此範例中，我們會新增在銷售部門中識別碼為 000152、且姓氏為 Jones 的員工：  
1.  擷取的索引實體 **PartitionKey** 值"Sales"和 **RowKey** 值"Jones"。 儲存此實體的 ETag　以在步驟 2 中使用。  
2.  建立實體群組交易 (也就是批次作業)，將新的員工實體 (**PartitionKey** 值"Sales"和 **RowKey** 值"000152")，並更新索引實體 (**PartitionKey** 值"Sales"和 **RowKey** 值"Jones") 將新的員工識別碼新增至 EmployeeIDs 欄位中的清單。 如需實體群組交易的詳細資訊，請參閱 [實體群組交易](#entity-group-transactions)。 
3.  如果實體群組交易因為開放式並行存取錯誤而失敗 (其他人剛修改過索引實體)，您就必須從步驟 1 重新執行。  

如果您使用第二個選項，您可以使用類似的方法來刪除某位員工。 變更員工的姓氏會稍微複雜一點，因為您需要執行會更新三個實體的實體群組交易：員工實體、舊姓氏的索引實體，與新姓氏的索引實體。 您必須先擷取每個實體才能進行變更，以擷取接著可以用來透過開放式並行存取執行更新的 ETag 值。  

下列步驟概述您在使用第二個選項、並需要查閱部門中所有具有給定姓氏的員工時所應遵循的程序。 在此範例中，我們會尋找銷售部門中所有姓氏為 Jones 的員工：  

1.  擷取的索引實體 **PartitionKey** 值"Sales"和 **RowKey** 值"Jones"。  
2.  剖析 EmployeeIDs 欄位中的員工識別碼清單。  
3.  如果您需要這些員工 (例如其電子郵件地址) 的詳細資訊，擷取每個員工實體使用 **PartitionKey** 值"Sales"和 **RowKey** 您在步驟 2 中取得的員工清單中的值。  

<u>選項 3:</u> 在個別的資料分割或資料表中建立索引實體  

使用第三個選項時，您會使用儲存下列資料的索引實體：  

![][15]

 **EmployeeIDs** 屬性包含員工識別碼清單的員工姓氏儲存在 **RowKey**。  

使用第三個選項時，您無法使用 EGT 來維持一致性，因為索引實體位於與員工實體不同的磁碟分割中。 您應確保索引實體與員工實體最終一致。  

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  
-   此解決方案需要至少兩個查詢來擷取相符實體: 一個用來查詢索引實體以取得清單 **RowKey** 值，然後查詢以擷取清單中的每個實體。  
-   假設個別實體的大小上限為 1 MB，方案中的選項 2 和選項 3 會假設任何給定姓氏的員工識別碼清單絕不會大於 1 MB。 如果員工識別碼清單的大小可能大於 1 MB，請使用選項 1，並將索引資料儲存在 Blob 儲存體中。  
-   如果您使用選項 2 (使用 EGT 處理新增和刪除員工以及變更員工姓氏的作業)，您必須評估交易量是否會接近給定資料分割中的延展性限制。 如果會，您應考慮最終一致方案 (選項 1 或選項 3)，以使用佇列來處理更新要求，並讓您將索引實體儲存在與員工實體不同的個別資料分割中。  
-   此方案中的選項 2 會假設您想要依姓氏在某部門內進行查閱：例如，您要擷取銷售部門中姓氏為 Jones 的員工清單。 如果您想要能夠查閱整個組織中姓氏為 Jones 的所有員工，請使用選項 1 或選項 3。
-   您可以實作以佇列為基礎的解決方案，提供最終一致性 (請參閱 [最終一致的交易模式](#eventually-consistent-transactions-pattern) 如需詳細資訊)。  

#### 使用此模式的時機  

如果您想要查閱全部共用通用屬性值的一組實體 (例如姓氏為 Jones 的所有員工)，請使用此模式。  

#### 相關的模式和指引  

在實作此模式時，下列模式和指導方針也可能有所關聯：  
-   [複合索引鍵模式](#compound-key-pattern)  
-   [最終一致的交易模式](#eventually-consistent-transactions-pattern)  
-   [實體群組交易](#entity-group-transactions)  
-   [使用異質性實體類型](#working-with-heterogeneous-entity-types)  

### 去正規化模式  

將相關資料結合在單一實體中，讓您透過單點查詢擷取所有您所需的資料。  

#### 內容和問題  

在關聯式資料庫中，您通常會將資料正規化，以移除會產生查詢而從多個資料表擷取資料的重複資料。 如果您將 Azure 資料表中的資料標準化，您必須從用戶端到伺服器往返多次才能擷取相關的資料。 以如下的資料表結構為例，您需要往返兩次才能擷取某部門的詳細資料：一個用來擷取包含經理識別碼的部門實體，另一個要求用來擷取員工實體中的經理詳細資料。  

![][16]

#### 方案  

不要將資料儲存在兩個不同的實體中，而將資料去正規化，並將管理員詳細資料的複本保存在部門實體中。 例如：  

![][17]

部門實體連同這些屬性一起儲存後，您現在可以擷取與使用點查詢的部門有關的所有詳細資料。  

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  

-   儲存資料兩次還有一些相關的成本負擔。 效能優勢 (因對儲存體服務的要求較少而產生) 通常會高於儲存體成本的邊際增值 (而且這項成本有部分會由擷取部門的詳細資料所需的交易量減少而抵銷)。  
-   您必須讓儲存管理員相關資訊的兩個實體保有一致性。 您可以使用 EGT 在單一不可部分完成交易中更新多個實體，以處理一致性問題：在此情況下，部門實體和部門經理的員工實體會儲存在相同的資料分割中。  

#### 使用此模式的時機
如果您經常需要查閱相關資訊，請使用此模式。 此模式可減少用戶端在擷取其所需資料時必須執行的查詢數目。  

#### 相關的模式和指引
在實作此模式時，下列模式和指導方針也可能有所關聯：  
-   [複合索引鍵模式](#compound-key-pattern)  
-   [實體群組交易](#entity-group-transactions)  
-   [使用異質性實體類型](#working-with-heterogeneous-entity-types)

### 複合索引鍵模式  

使用複合 **RowKey** 值，讓用戶端查閱與單點查詢的相關的資料。  

#### 內容和問題  

在關聯式資料庫中常會在查詢中使用聯結，將單一查詢中的相關資料片段傳回至用戶端。 例如，您可以使用員工識別碼來查閱包含該員工之績效和考核資料的相關實體清單。  

假設您要使用下列結構在資料表服務中儲存員工實體：  

![][18]

您也需要儲存該員工在組織中工作各年度的考核和績效相關歷史資料，而且您必須能夠依年份存取這項資訊。 建立另一個資料表來儲存具有下列結構的實體，是可行選項之一：  

![][19]

請注意，使用此方法時，您可以選擇在新的實體中重複某些資訊 (例如名字和姓氏)，以便透過單一要求擷取您的資料。 不過，您無法維護強式一致性，因為您無法使用 EGT 自動更新兩個實體。  

#### 方案
使用具有下列結構的實體，在您的原始資料表中儲存新的實體類型：  

![][20]

請注意如何 **RowKey** 是現在的員工識別碼和當年考核資料，可讓您擷取員工的績效和考核資料的單一實體的單一要求所組成的複合索引鍵。  

下列範例說明如何擷取特定員工的所有考核資料 (例如銷售部門的員工 000123)：  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### 問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

-   您應該使用適當的分隔符號字元，以簡化剖析 **RowKey** 值: 例如， **000123_2012**。  
-   您也必須將此實體儲存在與包含相同員工之相關資料的其他實體相同的資料分割中，這表示您可以使用 EGT 來維護強式一致性。
-   您應考量您查詢資料的頻率，以判斷此模式是否適用。  比方說，如果您不會經常存取考核資料和主要員工資料，則應將其保存為個別的實體。  

#### 使用此模式的時機  

如果您需要儲存一或多個您經常查詢的相關實體，請使用此模式。  

#### 相關的模式和指導方針  

在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [實體群組交易](#entity-group-transactions)  
-   [使用異質性實體類型](#working-with-heterogeneous-entity-types)  
-   [最終一致的交易模式](#eventually-consistent-transactions-pattern)  

### 記錄檔結尾模式  

擷取 *n* 最近新增至資料分割所使用的實體 **RowKey** 以反向的日期和時間順序排序的值。  

#### 內容和問題  

常見的需求是要能夠擷取最近建立的實體，例如員工最近提交的費用請款。 資料表查詢支援 **$top** 查詢作業，以傳回第一個 *n* 從一組實體: 沒有對等的查詢作業可傳回的集合中的最後 n 個實體。  

#### 方案  

將使用的實體儲存 **RowKey** 注意自然地使用使最新的項目反向的日期/時間順序來排序一律是第一個資料表中的。  

比方說，若要能夠擷取某員工最近提交的十筆費用請款，您可以使用衍生自目前日期/時間的反向刻度值。 下列 C# 程式碼範例示範如何建立適合 「 反向刻度 」 值，如 **RowKey** ，從最新排序到最舊:  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

您可以使用下列程式碼回到日期時間值：  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

資料表查詢如下所示：  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  

-   您必須為反向刻度值填補前置零，以確保字串值如預期排序。  
-   您必須知道資料分割層級的延展性目標。 請留意不要建立熱點資料分割。  

#### 使用此模式的時機  

當您需要存取反向日期/時間順序的實體時，或當您需要存取最近新增的實體時，請使用此模式。  

#### 相關的模式和指導方針  

在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [在前面加上/附加反向模式](#prepend-append-anti-pattern)  
-   [擷取實體](#retrieving-entities)  

### 大量刪除模式  

藉由將所有要同時刪除的實體儲存在其本身的個別資料表中，讓您能夠刪除大量的實體；您可以藉由刪除資料表來刪除實體。  

#### 內容和問題  

許多應用程式刪除用戶端應用程式已無需使用的舊資料，或應用程式已封存至其他儲存媒體的舊資料。 一般而言，您可以依日期來識別這類資料：例如，您需要刪除所有存留期超過 60 天之登入要求的記錄。  

一個可行的設計是要使用的日期和時間在登入要求 **RowKey**:  

![][21]

這個方法可避免產生資料分割熱點，因為應用程式可以在個別的資料分割中插入和刪除每一位使用者的登入實體。 不過如果您有大量的實體，這種方法可能既昂貴又耗時，因為您必須先執行資料表掃描以識別所有要刪除的實體，然後必須刪除每個舊的實體。 請注意，您可以藉由將多個刪除要求批次處理到 EGT 中，以減少刪除舊實體所需的伺服器往返次數。  

#### 方案  

為每天的登入嘗試使用個別的資料表。 當您要插入的實體時，您可以使用上述的實體設計來避免熱點，且刪除舊實體目前只不過是每天刪除一個資料表 (單一儲存體作業) 的問題而已，而無須每天尋找和刪除成千上百的個別登入實體。  

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  

-   您的設計是否支援應用程式使用資料的其他方式，例如查閱特定實體、連結其他資料或產生彙總資訊？  
-   您的設計在插入新實體時是否可避免產生熱點？  
-   如果您在刪除某個資料表名稱後想要加以重複使用，預期應會有延遲。 最好是一律使用唯一的資料表名稱。  
-   當您第一次使用新的資料表時，若資料表服務可辨識存取模式，並將資料分割散發到各節點，預期應會有節流。 您應考量您需要建立新資料表的頻率。  

#### 使用此模式的時機  

如果您有大量的實體必須同時刪除，請使用此模式。  

#### 相關的模式和指導方針  

在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [實體群組交易](#entity-group-transactions)
-   [修改實體](#working-with-heterogeneous-entity-types)  

### 資料序列模式  

將完整資料序列儲存在單一實體中，以盡可能減少您提出的要求數。  

#### 內容和問題  

常見的案例是應用程式需一次儲存必須經常擷取的資料序列。 比方說，您的應用程式可能會記錄每一位員工每小時傳送多少 IM 訊息，然後使用這項資訊來繪製每個使用者在過去 24 小時內傳送的訊息數。 一個設計可為每個員工儲存 24 個實體：  

![][22]

採用這種設計，您可以輕鬆地找出並更新實體，以在應用程式需要更新訊息計數值時更新每個員工。 不過，若要擷取資訊以繪製過去 24 小時內的活動圖，您必須擷取 24 個實體。  

#### 方案  

使用下列具有個別屬性的設計，儲存每個小時的訊息計數：  

![][23]

透過這項設計，您可以使用合併作業來更新員工在特定時段內的訊息計數。 現在，您可以使用單一實體的要求，擷取您要繪圖所需的所有資訊。  

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  
-   如果您完整資料序列不適用於單一實體 (一個實體可以有 252 個屬性)，請使用替代資料存放區，例如 Blob。  
-   如果您有多個用戶端同時更新實體時，您必須使用 **ETag** 實作開放式並行存取。 如果您有許多用戶端，則預期應會有激烈的爭用情況。  

#### 使用此模式的時機  

如果您需要更新和擷取與個別實體相關聯的資料序列，請使用此模式。  

#### 相關的模式和指導方針  

在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [大型實體模式](#large-entity-pattern)  
-   [合併或取代](#working-with-heterogeneous-entity-types)  
-   [最終一致的交易模式](#eventually-consistent-transactions-pattern) (如果您要將儲存的資料數列在 blob 中)  

### 寬型實體模式  

使用多個實際的實體來儲存具有超過 252 個屬性的邏輯實體。  

#### 內容和問題  

個別實體可以擁有超過 252 個 (不含必要的系統屬性) 屬性，而且無法儲存總計超過 1 MB 的資料。 在關聯式資料庫中，您會通常可藉由新增資料表並對其施行一對一關聯性，來解決任何資料列的大小限制。  

#### 方案  

使用資料表服務，可讓您儲存多個實體來代表具有超過 252 個屬性的單一大型商業物件。 例如，如果您想要儲存每個員工在 365 天內傳送的 IM 訊息計數，您可以採用下列設計，使用兩個具有不同結構描述的實體：  

![][24]

如果您需要進行必須同時更新兩個實體的變更，讓它們彼此保持同步，您可以使用 EGT。 否則，您可以使用合併作業來更新某天的訊息計數。 若要擷取個別員工的所有資料，您必須都擷取這兩個實體，您可以使用兩個同時使用的有效要求 **PartitionKey** 和 **RowKey** 值。  

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  

-   擷取完成邏輯實體牽涉到至少兩個儲存體交易：一個用來擷取每個實際的實體。  

#### 使用此模式的時機  

使用此模式時，需要儲存的大小或屬性的數目超過限制的資料表服務中的個別實體的實體。  

#### 相關的模式和指引  

在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [實體群組交易](#entity-group-transactions)
-   [合併或取代](#working-with-heterogeneous-entity-types)

### 大型實體模式  

使用 Blob 儲存體來儲存大型屬性值。  

#### 內容和問題  

個別實體無法儲存總計超過 1 MB 的資料。 如果有一或多個屬性所儲存的值會導致您的實體大小總計超過此值，您將無法在資料表服務中儲存整個實體。  

#### 方案  

如果您的實體因為一或多個屬性包含大量資料而使大小超過 1 MB，您可以將資料儲存在 Blob 服務，然後將 Blob 的位址儲存在實體的屬性中。 例如，您可以在 [blob 儲存體中儲存員工的相片，並儲存在相片的連結 **相片** 員工實體的屬性:  

![][25]

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  

-   若要讓資料表服務中的實體與 Blob 服務中的資料之間保有最終一致性，使用 [最終一致的交易模式](#eventually-consistent-transactions-pattern) 來維護您的實體。
-   擷取完整實體牽涉到至少兩個儲存體交易：一個用來擷取實體，另一個擷取 Blob 資料。  

#### 使用此模式的時機  

如果需要在資料表服務中儲存大小超過個別實體限制的實體，請使用此模式。  

#### 相關的模式和指導方針  

在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [最終一致的交易模式](#eventually-consistent-transactions-pattern)  
-   [寬型實體模式](#large-entity-pattern)

### 在前面加上/附加反向模式  

當您有大量插入作業時，請將插入作業分散到多個資料分割之間，請增加延展性。  

#### 內容和問題  

在前面加上或附加實體至您已儲存的實體，通常會導致應用程式將新實體新增至資料分割序列的第一個或最後一個資料分割。 在此情況下，所有在任何給定時間的插入將會在相同的資料分割中執行，而產生使資料表服務無法將插入負載平衡到多個節點間的熱點，且可能會造成您的應用程式達到資料分割的延展性目標。 例如，如果您的應用程式會記錄員工的網路和資源存取，且交易的數量已達到個別資料分割的延展性目標，則如下的實體結構可能會導致當下的資料分割成為熱點：  

![][26]

#### 方案  

下列替代實體結構可在應用程式記錄事件時避免在任何特定資料分割上產生熱點：  

![][27]

請留意此範例如何同時 **PartitionKey** 和 **RowKey** 成為複合索引鍵。  **PartitionKey** 會使用部門和員工識別碼將記錄散發到多個資料分割。  

#### 問題和考量  

當您決定如何實作此模式時，請考慮下列幾點：  

-   可避免在插入時產生熱點資料分割的替代索引鍵結構，是否可有效支援用戶端應用程式發出的查詢？  
-   您預期的交易量是否表示您很可能會達到個別資料分割的延展性目標，而遭到儲存體服務的節流？  

#### 使用此模式的時機  

如果您的交易量在您存取熱點資料分割時很可能會導致儲存體服務執行節流，請避免在前面加上/附加反向模式。  

#### 相關的模式和指導方針  

在實作此模式時，下列模式和指導方針也可能有所關聯：  

-   [複合索引鍵模式](#compound-key-pattern)  
-   [記錄檔結尾模式](#log-tail-pattern)  
-   [修改實體](#working-with-heterogeneous-entity-types)  

### 記錄資料反向模式  

一般而言，您應該使用 Blob 服務來儲存記錄資料，而不是資料表服務。  

#### 內容和問題  

記錄資料的常見使用案例是要擷取特定日期/時間範圍內的選定記錄項目：例如，您想要尋找應用程式在特定日期的 15:04 到 15:06 之間記錄的所有錯誤和嚴重訊息。 不想要的日期和時間的記錄檔訊息來判斷儲存記錄實體的資料分割: 這會產生熱點資料分割，因為在任何給定時間，所有的記錄實體都會共用相同 **PartitionKey** 值 (請參閱章節 [在前面加上/附加反向模式](#prepend-append-anti-pattern))。 比方說，記錄訊息的下列實體結構描述會產生熱點資料分割，因為應用程式會將目前日期和小時的所有記錄訊息都寫入至資料分割：  

![][28]

在此範例中， **RowKey** 包括日期和時間的記錄檔訊息以確保記錄訊息在儲存日期/時間順序排列，且包含訊息識別碼，在有多個記錄訊息共用相同的日期和時間。  

另一種方法是使用 **PartitionKey** ，以確保應用程式將訊息寫入一個範圍內的資料分割。 例如，如果記錄訊息的來源可藉由某方式將訊息散發到許多資料分割，您可以使用下列實體結構描述：  

![][29]

不過，此結構描述的問題是，若要擷取特定時間範圍內的所有記錄訊息，您必須在資料表中搜尋每個資料分割。

#### 方案  

上一節加強說明了嘗試使用資料表服務來儲存記錄項目的問題，並提供了兩個無法令人滿意的設計。 一個方案會導致熱點資料分割，且具有寫入記錄檔訊息效能不佳的風險；另一個方案會導致查詢效能不佳，因為必須要掃描資料表中的每個資料分割，才能擷取特定時間範圍內的記錄訊息。 Blob 儲存體可為這種類型的案例提供更好的方案，Azure Storage Analytics 就是以此方式來儲存它所收集到的記錄資料。  

本節概述 Storage Analytics 將記錄資料儲存在 Blob 儲存體中的方式，以說明如何以此方法儲存您常會依範圍查詢的資料。  

Storage Analytics 會以分隔格式將記錄訊息儲存在多個 Blob 中。 分隔格式可方便用戶端應用程式剖析記錄訊息中的資料。  

Storage Analytics 會為 Blob 使用命名慣例，讓您找出含有您要搜尋之記錄訊息的一或多個 Blob。 例如，名為 "queue/2014/07/31/1800/000001.log" 的 Blob，會包含與始於 2014 年 7 月 31 日 18:00 的佇列服務有關的記錄訊息。 "000001"表示這是這段期間的第一個記錄檔。 Storage Analytics 也會記錄在檔案中儲存為 Blob 中繼資料的第一個和最後一個記錄訊息的時間戳記。 Blob 儲存體的 API 可讓您根據名稱前置詞找出容器中的 Blob：若要尋找所有內含從 18:00 開始之佇列記錄資料的 Blob，您可以使用前置詞 "queue/2014/07/31/1800"。  

Storage Analytics 會在內部緩衝處理記錄訊息，然後定期更新適當的 Blob，或建立新的 Blob 來容納記錄項目的最新批次。 這會減少它必須對 Blob 服務執行的寫入數目。  

如果您在自己的應用程式中實作類似的方案，您必須考量如何管理可靠性 (在每個記錄項目發生時將其寫入至 Blob 儲存體)、成本和延展性 (在您的應用程式中緩衝處理更新，並將其分批寫入至 Blob 儲存體) 之間的取捨。  

#### 問題和考量  

當您決定如何儲存記錄資料時，請考慮下列幾點：  

-   如果您建立的資料表設計可避免產生潛在的熱點資料分割，您可能會發現您無法有效率地存取記錄資料。  
-   在處理記錄資料時，用戶端常需要載入多筆記錄。  
-   雖然記錄資料通常是結構化的，Blob 儲存體會是較佳的方案。  

### 實作考量  

本節討論您在實作前面幾節說明的模式時應謹記在心的注意事項。 本節中的範例大多是以 C# 撰寫，並使用儲存體用戶端程式庫 (撰寫本文時為 4.3.0 版)。  

### 擷取實體  

一節中所述 [查詢的設計](#design-for-querying),，「 最有效率的查詢是點查詢。 但在某些情況下，您可能需要擷取多個實體。 本節說明使用儲存體用戶端程式庫來擷取實體的一些常見方法。  

#### 使用儲存體用戶端程式庫執行點查詢  

執行點查詢最簡單的作法是使用 **擷取** 資料表作業，如下列 C# 程式碼片段會擷取一個實體中所示 **PartitionKey** 值"Sales"和 **RowKey** 值為"212"的:  

    TableOperation retrieveOperation =
        TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
    var retrieveResult = employeeTable.Execute(retrieveOperation);
    if (retrieveResult.Result != null)
    {
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
    }  

請注意，此範例預期實體型別，它會擷取 **EmployeeEntity**。  

#### 使用 LINQ 擷取多個實體  

您可以使用 LINQ 與儲存體用戶端程式庫，並指定使用查詢擷取多個實體 **其中** 子句。 若要避免資料表掃描，您應該永遠包含 **PartitionKey** 值的 where 子句，並盡可能 **RowKey** 值，以防止資料表和資料分割掃描。 資料表服務支援在 where 子句中使用一組有限的比較運算子 (大於、大於或等於、小於、小於或等於、等於和不等於)。 下列 C# 程式碼片段會以"B"姓氏開頭尋找所有員工 (假設 **RowKey** 儲存姓氏) 業務部門 (假設 **PartitionKey** 儲存部門名稱):  

    TableQuery<EmployeeEntity> employeeQuery =
            employeeTable.CreateQuery<EmployeeEntity>();
    var query = (from employee in employeeQuery
                where employee.PartitionKey == "Sales" &&
                employee.RowKey.CompareTo("B") >= 0 &&
                employee.RowKey.CompareTo("C") < 0
                select employee).AsTableQuery();
    var employees = query.Execute();  

請注意查詢如何指定同時 **RowKey** 和 **PartitionKey** 以確保更好的效能。  

下列程式碼範例說明使用 fluent API 的對等功能 (如需 fluent Api 的詳細資訊一般情況下，請參閱 [設計 Fluent API 的最佳作法](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):  

    TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
     TableQuery.CombineFilters(
        TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales"),
      TableOperators.And,
      TableQuery.GenerateFilterCondition(
        "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
    ),
    TableOperators.And,
    TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
     )
    );
    var employees = employeeTable.ExecuteQuery(employeeQuery);  


>[AZURE.NOTE] 此範例內嵌了多個 **CombineFilters** 方法，以納入三個篩選條件。  

#### 從查詢擷取大量實體  

最佳查詢會傳回個別實體根據 **PartitionKey** 值和 **RowKey** 值。 但在某些情況下，您可能需要從相同的磁碟分割甚或多個資料分割傳回許多實體。  

在此類情況下，您務必要完整測試應用程式的效能。  

對資料表服務的查詢一次最多可傳回 1000 個實體，且最長可執行五秒。 如果結果集包含超過 1000 個實體，且查詢未於五秒內完成，或者查詢跨越資料分割界限，則資料表服務會傳回接續權杖，讓用戶端應用程式能夠要求下一組實體。 如需接續權杖如何運作的詳細資訊，請參閱 [查詢逾時和分頁](http://msdn.microsoft.com/library/azure/dd135718.aspx) MSDN 上。  

如果您使用儲存體用戶端程式庫，它可以在從資料表服務傳回實體時，自動為您處理接續權杖。 下列使用儲存體用戶端程式庫的 C# 程式碼範例會在資料表服務於回應中傳回接續權杖時自動處理接續權杖：  

    string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
    TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

    var employees = employeeTable.ExecuteQuery(employeeQuery);
    foreach (var emp in employees)
    {
        ...
    }  

下列 C# 程式碼會明確處理接續權杖：  

    string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
    TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

    TableContinuationToken continuationToken = null;

    do
    {
        var employees = employeeTable.ExecuteQuerySegmented(
            employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
     ...
    }
    continuationToken = employees.ContinuationToken;
    } while (continuationToken != null);  

藉由明確使用接續權杖，您將可控制應用程式何時會擷取下一個資料區段。 例如，如果用戶端應用程式可讓使用者逐頁查看儲存在資料表中的實體，使用者可以決定不逐頁查看查詢所擷取的所有實體，而在使用者逐頁查看完目前區段中的所有實體時，您的應用程式才會使用接續權杖擷取下一個區段。 這種方法有幾項優點：  

-   它可讓您限制要從資料表服務擷取的資料量，以及在網路上移動的資料量。  
-   它可讓您在 .NET 中執行非同步 IO。  
-   它可讓您序列化永續性儲存體的接續權杖，以便在應用程式當機時繼續作業。  

>[AZURE.NOTE] 接續權杖通常會傳回區段，其中包含 1000 個實體，但也可能較少。 這也是如果您限制使用的查詢傳回的項目數如此 **採取** 傳回符合查閱準則的前 n 個實體: 資料表服務可能會傳回包含少於 n 個實體以及接續權杖，讓您能夠擷取剩餘的實體的區段。  

下列 C# 程式碼說明如何修改區段內傳回的實體數目：  

    employeeQuery.TakeCount = 50;  

#### 伺服器端預測  

單一實體最多可以有 255 個屬性，且大小上限為 1 MB。 當您查詢資料表並擷取實體時，您可能不需要所有屬性，並可以避免不必要地傳送資料 (以利降低延遲和成本)。 您可以使用伺服器端預測，僅傳送您需要的屬性。 下列範例會擷取只 **電子郵件** 屬性 (連同 **PartitionKey**, ，**RowKey**, ，**時間戳記**, ，和 **ETag**) 從查詢所選取的實體。  

    string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
    List<string> columns = new List<string>() { "Email" };
    TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

    var entities = employeeTable.ExecuteQuery(employeeQuery);
    foreach (var e in entities)
    {
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
    }  

請注意如何 **RowKey** 值為止，即使不包含要擷取的屬性清單中。  

### 修改實體  

儲存體用戶端程式庫可讓您藉由插入、刪除和更新實體，修改您儲存在資料表服務中的實體。 您可以使用 EGT 一併批次處理多個插入、更新和刪除作業，以減少所需的往返次數，並改善方案的效能。  

請注意，當儲存體用戶端程式庫執行 EGT 時，通常預期會包含造成批次失敗的實體索引。 當您偵錯使用 EGT 的程式碼時，這會很有幫助。  

您也應該考量您的設計會如何影響用戶端應用程式處理並行存取和更新作業的方式。  

#### 管理並行存取  

根據預設，資料表服務會實作開放式並行存取檢查的個別實體的層級 **插入**, ，**合併**, ，和 **刪除** 作業，雖然它可讓用戶端強制資料表服務略過這些檢查。 如需有關資料表服務如何管理並行存取的詳細資訊，請參閱  [管理 Microsoft Azure 儲存體中的並行存取](storage-concurrency.md) 在 Microsoft Azure 網站上。  

#### 合併或取代  

 **取代** 方法 **TableOperation** 類別一律會取代資料表服務中的完整實體。 如果您未在要求中包含某個屬性，而該屬性存在於已儲存的實體中，要求將會從已儲存的實體中移除該屬性。 除非您想要明確地從已儲存的實體中移除屬性，否則即必須在要求中包含每個屬性。  

您可以使用 **合併** 方法 **TableOperation** 類別，以減少您想要更新實體時傳送至資料表服務的資料量。  **合併** 方法中，在要求中包含之實體的屬性值取代儲存的實體中的任何屬性，但保留資料庫中儲存的實體不包含在要求的任何屬性。 如果您有大型實體，而只需要更新要求中的少數屬性，這就非常有用。  

>[AZURE.NOTE]  **取代** 和 **合併** 方法失敗，如果實體不存在。 或者，您可以使用 **InsertOrReplace** 和 **InsertOrMerge** 方法建立新的實體，如果不存在。  

### 使用異質性實體類型  

資料表服務是 *無結構描述* 資料表存放區，這表示單一資料表可以儲存多種類型，提供更多的彈性設計的實體。 下列範例說明用以儲存員工和部門實體的資料表：  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

請注意，每個實體仍必須要有 **PartitionKey**, ，**RowKey**, ，和 **時間戳記** 值，但是可能會有任何屬性集。 此外，除非您選擇將實體類型資訊儲存在某處，否則將沒有項目會指出此類型。 有兩個選項可用來識別實體類型：  

-   在前面加上實體類型 **RowKey** (或可能 **PartitionKey**)。 例如， **EMPLOYEE_000123** 或 **DEPARTMENT_SALES** 為 **RowKey** 值。  
-   使用個別屬性記錄實體類型，如下表所示。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>員工</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>員工</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>部門</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>員工</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

第一個選項，前面加上實體類型 **RowKey**, ，如果兩個不同類型的實體可能有相同的金鑰值可能會很有用。 它也會將屬於相同類型的實體分組在資料分割中。  

本章節中討論的技術有密切的討論 [繼承關聯性](#inheritance-relationships) 一節中本指南稍早 [模型化關聯性](#modelling-relationships)。  

>[AZURE.NOTE] 您應該考慮在實體類型值，讓用戶端應用程式能夠演化 POCO 物件，並使用不同版本中包含版本號碼。  

本節的其餘部分說明儲存體用戶端程式庫中一些有助於在相同資料表中使用多個實體類型的功能。  

#### 擷取異質性實體類型  

在使用儲存體用戶端程式庫時，有三個選項可供您使用多個實體類型。  

如果您知道的儲存與特定實體類型 **RowKey** 和 **PartitionKey** 值，那麼當您擷取實體中擷取實體類型的先前兩個範例所示，您可以指定實體類型 **EmployeeEntity**: [擷取單一實體儲存體用戶端程式庫](#retrieving-a-single-entity-using-the-storage-client-library) 和 [擷取多個實體使用 LINQ](#retrieving-multiple-entities-using-linq)。  

第二個選項是使用 **DynamicTableEntity** 類型 (屬性包)，而不是具體的 POCO 實體類型 (這個選項也可改善效能因為不需要序列化和還原序列化成.NET 類型的實體)。 下列 C# 程式碼可能從資料表中，擷取不同類型的多個實體，但會傳回所有實體做為 **DynamicTableEntity** 執行個體。 然後它會使用 **EntityType** 屬性來判斷每個實體類型:  

    string filter =     TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition("PartitionKey",
      QueryComparisons.Equal, "Sales"),
        TableOperators.And,
        TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
            TableOperators.And,
            TableQuery.GenerateFilterCondition("RowKey",
          QueryComparisons.LessThan, "F")
        )
    );
    TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
    var employees = employeeTable.ExecuteQuery(entityQuery);

    IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
    foreach (var e in entities)
    {
    EntityProperty entityTypeProperty;
    if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
    {
        if (entityTypeProperty.StringValue == "Employee")
        {
            // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
          }
     }
    }  

請注意，才能擷取其他屬性，您必須使用 **TryGetValue** 方法 **屬性** 屬性 **DynamicTableEntity** 類別。  

第三個選項是結合使用 **DynamicTableEntity** 型別和 **EntityResolver** 執行個體。 這可讓您解析為相同查詢中的多個 POCO 類型。 在此範例中， **EntityResolver** 委派會使用 **EntityType** 屬性來區別兩個查詢所傳回的實體類型。  **解決** 方法會使用 **解析程式** 委派，將 **DynamicTableEntity** 執行個體來 **TableEntity** 執行個體。  

    EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
    {

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
            resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
            resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
    };

    string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
    TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

    var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
    foreach (var e in entities)
    {
        if (e is DepartmentEntity)
        {
        ...
        }
        if (e is EmployeeEntity)
        {
        ...
        }
    }  

#### 修改異質性實體類型  

您不需要知道實體的類型即可加以刪除，而在您插入實體時一定會知道其類型。 不過，您可以使用 **DynamicTableEntity** 更新實體，而不需要知道其類型，且無須使用 POCO 實體類別的型別。 下列程式碼範例會擷取單一實體，並確認 **EmployeeCount** 屬性存在，然後再更新它。  

    TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
    DynamicTableEntity department = (DynamicTableEntity)result.Result;

    EntityProperty countProperty;

    if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
    {
        throw new
            InvalidOperationException("Invalid entity, EmployeeCount property not found.");
    }
    countProperty.Int32Value += 1;
    employeeTable.Execute(TableOperation.Merge(department));  

### 使用共用存取簽章控制存取  

您可以使用共用存取簽章 (SAS) 權杖讓用戶端應用程式能夠修改 (和查詢) 資料表實體，而不需要直接使用資料表服務進行驗證。 一般而言，在您的應用程式中使用 SAS 有三大優點：  

-   您不需要為了要讓裝置可存取和修改資料表服務中的實體，而將儲存體帳戶金鑰散發至不安全的平台 (例如行動裝置)。  
-   您可以將 Web 和背景工作角色為了管理實體而執行的某些工作，卸載至使用者電腦和行動裝置之類的用戶端裝置。  
-   您可以為用戶端指派受條件約束和時間限制的權限集 (例如允許對特定資源的唯讀存取)。  

如需使用 SAS 權杖與資料表服務的詳細資訊，請參閱 [共用存取簽章，第 1 部分: 了解 SAS 模型](../storage-dotnet-shared-access-signature-part-1/)。  

不過，您仍必須產生SAS 權杖，讓用戶端應用程式有權使用資料表服務中的實體：您應在可安全存取儲存體帳戶金鑰的環境中執行這個動作。 一般而言，您可以使用 Web 或背景工作角色來產生 SAS 權杖，並將其傳送至需要存取您的實體的用戶端應用程式。 由於產生 SAS 權杖並將其傳遞至用戶端仍會產生額外負荷，因此您應考量怎樣最能降低此負荷，尤其是在大量的案例中。  

您可以產生特定 SAS 權杖，使其授與對資料表中的實體子集進行存取的權限。 根據預設，您會建立 SAS 權杖，針對整個資料表，但也可以指定 SAS 權杖授予存取各種 **PartitionKey** 值或一系列 **PartitionKey** 和 **RowKey** 值。 您可以選擇為系統的個別使用者產生 SAS 權杖，使每位使用者的 SAS 權杖只允許他們在資料表服務中存取自己的實體。  

### 非同步和平行作業  

假設您要跨多個資料分割分散您的要求，您可以使用非同步或平行查詢來改善輸送量和用戶端的回應性。
例如，您可以用兩個或更多背景工作角色執行個體，以平行方式存取您的資料表。 您可以讓個別的背景工作角色負責特定的資料分割集，或僅使用多個背景工作角色執行個體，使其分別都能夠存取資料表中的所有資料分割。  

在用戶端執行個體中，您可以藉由以非同步方式執行儲存作業來提高輸送量。 儲存體用戶端程式庫可讓您輕鬆撰寫非同步查詢並修改。 比方說，首先您可以使用同步方法來擷取資料分割中的所有實體，如下列 C# 程式碼所示：  

    private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
    {
        string filter = TableQuery.GenerateFilterCondition(
            "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
            new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
            var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
            foreach (var emp in employees)
        {
        ...
        }
            continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
    }  

您可以輕鬆地修改此程式碼，讓查詢以非同步方式執行，如下所示：  

    private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
    {
        string filter = TableQuery.GenerateFilterCondition(
            "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
            new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
            var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
            foreach (var emp in employees)
            {
             ...
            }
            continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
    }  

在此非同步範例中，您可以看到下列與同步版本不同的變更：  

-   方法簽章現在包含 **非同步** 修飾詞，並且傳回 **工作** 執行個體。  
-   而不是呼叫 **Executesegmentedasync** 方法來擷取結果，現在方法會呼叫 **Await** 方法，並使用 **await** 修飾詞以非同步方式擷取結果。  

用戶端應用程式可以呼叫此方法多次 (使用不同的值，如 **部門** 參數)，每個查詢會在個別的執行緒上執行。  

請注意，有沒有非同步版本 **Execute** 方法中的 **TableQuery** 類別，因為 **IEnumerable** 介面不支援非同步列舉。  

您也可以透過非同步方式插入、更新和刪除實體。 下列 C# 範例說明如何以簡單的同步方法來插入或取代員工實體：  

    private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
    {
        TableResult result = employeeTable
            .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
    }  

您可以輕鬆地修改此程式碼，讓更新以非同步方式執行，如下所示：  

    private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
    {
        TableResult result = await employeeTable
            .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
    }  

在此非同步範例中，您可以看到下列與同步版本不同的變更：  

-   方法簽章現在包含 **非同步** 修飾詞，並且傳回 **工作** 執行個體。  
-   而不是呼叫 **Execute** 方法來更新實體，現在方法會呼叫 **ExecuteAsync** 方法，並使用 **await** 修飾詞以非同步方式擷取結果。  

用戶端應用程式可以呼叫多個此類的非同步方法，每個方法叫用會在個別的執行緒上執行。  


### 感謝
我們想要感謝下列成員的 Azure 團隊的貢獻: Dominic Betts、 Jason Hogg、 Jean Ghanem、 Jai Haridas、 Jeff Irwin、 Vamshidhar Kommineni、 Vinay Shah 和 Serdar Ozler，以及來自 Microsoft DX 的 Tom Hollander。 

我們也要感謝下列 Microsoft MVP 在審閱期間提供了寶貴意見：Igor Papirov 和 Edward Bakker。



[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png
 


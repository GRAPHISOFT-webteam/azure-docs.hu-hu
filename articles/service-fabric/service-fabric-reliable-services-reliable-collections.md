<properties
   pageTitle="可靠的集合 | Microsoft Azure"
   description="Service Fabric 具狀態服務提供可靠的集合，可讓您撰寫高度可用、可調整且低延遲的雲端應用程式。"
   services="service-fabric"
   documentationCenter=".net"
   authors="mcoskun"
   manager="timlt"
   editor="masnider,jessebenson"/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="required"
   ms.date="11/11/2015"
   ms.author="mcoskun"/>

# Service Fabric 具狀態服務中之可靠的集合簡介

可靠的集合可讓您撰寫高度可用、 可擴充且低延遲
雲端應用程式，就好像您正在撰寫單一機器應用程式。
中的類別 `Microsoft.ServiceFabric.Data.Collections` 命名空間提供的方塊外的一組
讓您自動狀態高度可用的集合。
開發人員只需要將程式設計為可靠的集合 Api，並讓可靠的集合
管理複寫和本機狀態。

可靠的集合和其他高可用性技術之間的主要差異
(例如 Redis、 Azure 資料表服務和 Azure 佇列服務) 時的狀態
保留在本機服務執行個體時也被設定為高可用性。
這表示：

1. 所有讀取都在本機，可保障低延遲及高輸送量讀取。
2. 所有寫入都只會產生最少網路 IO 數，可保障低延遲和高輸送量寫入。

![集合的演化圖。](media/service-fabric-reliable-services-reliable-collections/ReliableCollectionsEvolution.png)

可靠的集合可以視為的自然進化 `System.Collections`
類別: 一組新的集合，專為雲端和多台電腦
而不會增加複雜性，開發人員適用的應用程式。
因此，它們是：

1. 可複寫：進行狀態變更複寫以確保高可用性。
2. 可保存：資料會保存至磁碟，可在發生大規模中斷 (例如，資料中心停電) 時保障持續性。
3. 非同步：非同步 API，可確保在產生 IO 時不會封鎖執行緒。
4. 交易式：API 利用交易抽象方法，讓您輕鬆管理服務內多個可靠的集合。

可靠的集合提供強式一致性可保證現成的順序
為了方便推理應用程式的狀態。
強式一致性即可確保整個交易後才完成的交易認可
已經套用到包括主要複本的仲裁。
若要達成較弱的一致性，應用程式可以通知傳回給用戶端 / 要求者
之前在非同步認可傳回。

可靠的集合 Api 是並行集合 Api 的演進
(位於 `System.Collections.Concurrent` 命名空間):

1. 非同步：會傳回工作；不同於並行集合，其作業會受到複寫及保存。
2. 沒有 out 參數: 使用 `ConditionalResult<T>` 傳回 bool 和值，而不是 out 參數。 `ConditionalResult<T>` 就像 `Nullable<T>` ，但不需要 T 結構。
3. 交易：使用交易物件，讓使用者可在交易中的多個可靠的集合上群組動作。

目前，`Microsoft.ServiceFabric.Data.Collections` 包含兩個集合：

1. [可靠的字典](https://msdn.microsoft.com/library/azure/dn971511.aspx): 表示複寫、 交易式和非同步索引鍵/值組的集合。 類似於 `ConcurrentDictionary`，其索引鍵和值可以是任何類型。
2. [可靠的佇列](https://msdn.microsoft.com/library/azure/dn971527.aspx): 表示可複寫、 交易式和非同步嚴格先進先出 (FIFO) 佇列。 類似於 `ConcurrentQueue`，其值可以是任何類型。

## 隔離層級
隔離層級是所達隔離程度的量值。
隔離表示交易的行為會在系統中只允許
要在任何給定的時間點進行中的一筆交易。

可靠的集合會自動選擇要使用的隔離等級指定
讀取作業依據作業和複本的角色。

可靠的集合支援兩種隔離等級：

- **可重複讀取**: 「 指定陳述式無法讀取已修改但尚未由其他交易確認的資料和任何其他交易都可以修改目前交易完成之前，由目前交易已讀取的資料。 (https://msdn.microsoft.com/library/ms173763.aspx) 」
- **快照集**: 指定在交易中任何陳述式所讀取的資料將會在交易開始時存在的資料版本一致。 交易只能辨識交易開始之前所認可的資料修改。 在目前交易中執行的陳述式無法看到在目前交易開始之後，其他交易所進行的資料修改。 效果就如同交易中的陳述式會取得認可資料的快照集，因為這項資料於交易開始時就存在。 (https://msdn.microsoft.com/library/ms173763.aspx) 」

可靠的字典和可靠的佇列皆支援「讀寫一致性」(Read Your Writes)。
換句話說，會看到後續讀取交易內的任何寫入
屬於相同的交易。

### 可靠的字典
| 作業 \ 角色      | 主要          | 次要        |
| --------------------- | :--------------- | :--------------- |
| 單一實體讀取    | 可重複讀取  | 快照         |
| 列舉 \ 計數   | 快照         | 快照         |

### 可靠的佇列
| 作業 \ 角色      | 主要          | 次要        |
| --------------------- | :--------------- | :--------------- |
| 單一實體讀取    | 快照         | 快照         |
| 列舉 \ 計數   | 快照         | 快照         |

## 持續性模型
可靠的狀態管理員和可靠的集合會遵循持續性模型，該模型稱為「記錄檔和檢查點」(Log and Checkpoint)。
這個模型會將每個狀態變更記錄在磁碟上，並只套用在記憶體中。
完成狀態本身也只是偶爾保存 (也稱為 檢查點)。
它提供的好處為：

- 差異會轉變成磁碟上的循序附加專用寫入以改善效能。

為了進一步了解記錄檔和檢查點模型，我們來看看磁碟無限時的案例。
可靠的狀態管理員會在複寫作業之前，記錄每一項作業。
這可讓可靠的集合只在記憶體中套用作業。
因為記錄檔會保存，即使複本失敗而必須重新啟動，可靠狀態管理員
若要重新執行複本已遺失的所有作業記錄中有足夠的資訊。
由於磁碟是無限的，因此永遠都不需要移除記錄檔記錄，而可靠的集合就只需要管理記憶體內部的狀態。

現在讓我們看看磁碟有限的案例。
在某個時間點，可靠的狀態管理員會用完磁碟空間。
在這種情況發生前，可靠的狀態管理員必須截斷其記錄檔以騰出空間給較新的記錄。
它會要求可靠的集合對磁碟進行其記憶體內部狀態的檢查點檢查。
由可靠的集合負責保存到該點為止的狀態。
一旦可靠的集合完成其檢查點檢查，可靠的狀態管理員即可截斷記錄檔以釋放磁碟空間。
如此一來，當複本必須重新啟動，可靠的集合將會復原其
檢查點的狀態和可靠的狀態管理員會將復原並播放發生的所有狀態變更
因為檢查點。

## 鎖定
可靠的集合中所有交易都是兩個階段: 交易並不會釋放
終止與中止或認可交易之前，它所取得鎖定。

可靠的集合都需要獨佔鎖定。
對於讀取來說，鎖定取決於幾個因素而定。
任何使用快照隔離所完成的讀取作業是無鎖定的。
任何可重複讀取作業都預設會採用共用鎖定。
不過，任何讀取支援可重複讀取作業時，使用者可以要求
更新鎖定，而不共用鎖定。
更新鎖定是用來避免常見的死結形式的非對稱鎖定，
多個交易鎖定資源稍後可能更新時發生。

下列為鎖定相容性矩陣：

| 要求 \ 授與 | None         | 共用       | 更新      | 獨佔    |
| ----------------- | :----------- | :----------- | :---------- | :----------- |
| 共用            | 無衝突  | 無衝突  | 衝突    | 衝突     |
| 更新            | 無衝突  | 無衝突  | 衝突    | 衝突     |
| 獨佔         | 無衝突  | 衝突     | 衝突    | 衝突     |

請注意，可靠的集合 API 中的逾時引數是用來進行死結偵測。
例如，有兩筆交易 (T1 和 T2) 嘗試讀取和更新 K1。
這樣很可能會形成死結，因為它們最後都會有共用鎖定。
在這種情況下，其中一個或兩個作業就會逾時。

請注意，上述死結的案例就是更新鎖定可如何防止死結的絕佳範例。

## 建議

- **不這麼做** 修改讀取作業所傳回的自訂型別的物件 (例如 `TryPeekAsync` 或 `TryGetAsync`)。 可靠的集合就像並行的集合一樣，會傳回物件參考而不是複本。
- **請勿** 修改之前，就傳回的自訂類型物件的深層複本。 因為結構和內建類型都是傳值，因此您不需要在其上執行深層複製。
- **不這麼做** 使用 `TimeSpan.MaxValue` 逾時。 逾時應該用來偵測死結。
- **不這麼做** 建立另一個交易內的交易 `using` 陳述式因為它可能會造成死結。

以下是要牢記在心的一些事項：

- 所有可靠的集合 API 的預設逾時都是 4 秒。 大部分使用者應該都不會覆寫此預設值。
- 在所有可靠的集合 API 中，預設的取消權杖為 `CancellationToken.None`。
- 可靠字典的索引鍵類型參數 (TKey) 必須正確實作 GetHashCode() and Equals()。 索引鍵必須是不可變的。
- 在集合中，快照集中的列舉都是一致的。 但是，在跨多個集合的情況下，列舉並不是一致的。
- 若要讓可靠的集合達到高度可用性，每個服務應至少有一個目標和大小為 3 的最小複本集。

## 後續步驟

- [可靠的服務快速入門](service-fabric-reliable-services-quick-start.md)
- [開始使用 Service Fabric Web API 服務](service-fabric-reliable-services-communication-webapi.md)
- [可靠服務程式設計模型的進階用法](service-fabric-reliable-services-advanced-usage.md)
- [可靠的集合的開發人員參考資料](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)

